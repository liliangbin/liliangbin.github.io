<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jenkins配置]]></title>
    <url>%2F2019%2F04%2F15%2Fjenkins%2F</url>
    <content type="text"><![CDATA[准备工作，获取jenkins的deb文件（有的是用的war包）－ 我们先去其官网下载镜像。 https://jenkins.io/download/ 我们在这个地方下载ubuntu的 jenkins的安装。。 sudo dpkg -i jenkins.deb jenkins 查看是否安装成功service jenkins restart jenkins jenkins默认端口是8080 ,打开localhost:8080 因为这个文章是我已经搞定后再来写的就没有图了，直接说吧。 最开始进去的时候会叫你输入一个初始密码，，那个初始密码就在上面他给你的那个路径里面，你cat 出来粘贴上去就好。 然后一个很尴尬的事情，我当时遇到的是插件安装不上，，（offline)然后直接跳过。。然后叫你创建用户，密码。。这个后期登录用。－ 插件安装。git github maven ssh 然后本地maven jdk 配置。 - 在这个地方的java_home maven_home 是你的电脑jdk maven 安装路径。。 环境配置完成后。开始新建项目 构建项目,选择maven ,最后配置文件如图。 最后保存下来。主页面开始构建。。构建的目录在 /var/share/jenkins 这个目录下。默认，可能有不一样。 jenkins 端口配置。。－ 有的人可能8080端口被占用了，我们就可以把他的端口改到其他的地方。配置文件 var/lib/jenkins /etc/default/jenkins 这俩个都是配置文件，都需要我们去修改。。。。我是参照的这个人的一个博客。https://blog.whsir.com/post-1774.html 给大佬递茶。具体的配置端口就是把端口号改了就是了 网上还有通过改war 包运行的时候端口，，，没有试过，觉得这个不是一个很好的方法，，最好是改配置文件。。]]></content>
      <tags>
        <tag>linux，服务器运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用vmvare 安装一个Android for PC]]></title>
    <url>%2F2019%2F04%2F15%2FAndroid%2F</url>
    <content type="text"><![CDATA[准备工作 寻找Android镜像 http://www.android-x86.org/download //在这个平台上有很多的Android资源vmvare如何安装，在网上找到一个教程。 https://jingyan.baidu.com/article/7e4409531bf5252fc1e2ef67.html //最重要的是那个3D加速支持。。不然开始后就是一堆的命令行界面 同样，相同的方法可以运用到直接在日常用的PC机上安装Android。。但是没有找到有一个国内的Android 镜像]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello linux]]></title>
    <url>%2F2019%2F04%2F15%2FLinux_shell_command%2F</url>
    <content type="text"><![CDATA[shell命令apt cache get 12345$ sudo apt-cache search 安装的软件.....或是你不知道你需要的那个软件的名字。可以进行模糊的搜索$ sudo apt-cache search | grep 'jdk' //jdk是你要安装的软件包含的某个值 装软件的时候我们第一部总是需要先确认是那个软件 然后我们才能更加贴合我们的需求来找软件 123456$ sudo apt-get install software// 可能会需要不能安装的问题，告诉你可能存在依赖的问题 // 可能你需要这个命令$ sudo apt-get install -f // 修复依赖 同样如果再centos下面的话，包管理工具是yum 同样的可以用相同的方法。 123$ yum search jdk$ yum install **** nohup 这个命令代表的是后台挂起的意思。例如 nohup java -jar demo.jar &amp; &gt;log.txt 在这个里面nohup 代表后台挂起 &amp;代表的是退出session后不会停止 更多的更新以后在说]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[database]]></title>
    <url>%2F2019%2F04%2F15%2Fdatabase%2F</url>
    <content type="text"><![CDATA[数据库的更新以及备份导入（忘记给atom设置自动保存了，我特么）因为我们使用的是lnmp环境，所以在lnmp环境下，有一个upgrade.sh 可以直接用这个脚本进行更新，1./upgrade.sh mysql 使用lnmp进行全局的更新（感觉也是各个地方也是有了一些问题了，注意备份数据，忘记备份了nginx的数据） 备份数据，MySQL的备份数据方法，这个地方我使用的是备份所有的数据库，mysql dump命令，可以实现热备份，（以后可以考虑一下备份数据库 配合crontab ） 参考链接 MySQLdump备份数据库1mysqldump -u root -pPASSWORD --all-databases &gt; sqlfile.sql 备份好后会在当前文件夹下得到一个文件。 进入lnmp文件夹下后卸载lnmp（如何没有了再下载就行） 1./uninstall.sh lnmp环境的卸载的时候会自动给你生成一个备份的文件夹，（卸载完后才发现，我们也可以用这个文件夹的东西来进行数据的回复）可以参考这个博客lnmp的数据库备份文件夹 卸载完后再install嘛，这个不讨论了。我么再来数据的恢复。 1source sqlfile.sql //使用source命令还原数据库包括用户的配置 但是这个时候就再source完毕后出现问题。出现了拒绝访问的情况。1mysql -u root -p password //出现了拒绝访问的情况 这个问题是真的没道理，扎心，后来网上找打一个例子，这个是密码问题出问题了，所以我们采用跳过密码验证的那一步。参考这个地方mysqld免密登录 /etc/my.cnf 在里面的mysqld后加上 skip-grant-tables 然后我们重启MySQL。。。 后来的问题，数据库的3306端口莫名给关了修改/etc/syscong/iptables 里面关于数据库的3306的限制]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello liliangbin]]></title>
    <url>%2F2019%2F04%2F15%2Finnovation%2F</url>
    <content type="text"><![CDATA[基于云的服务 全部的数据都是在云端存储 现象 本地的资源使用度低， 安全性，存在被黑客渗透的危险 重装系统后环境和软件还需要自己重新配。 分析： 为什么利用低啦？ 现在这个已经做的很好了。我们还没有达到太大的需求。。。。 安全性能 ，数据都是在本地存储，同时由于我们上网习惯的不友好，容易让电脑暴露在黑客们的眼中。。。 有时候自己数据量太大。希望能够进行重置电脑，或是重装系统的时候，数据量太大，同时花的时间真多。 解决办法–方向由上面的这些原因我们可以知道。能解决这个的办法就是基于云了。。。 资源的利用率不高，那么我们就可以按需来分配资源。。本地留一定的缓存存储。同样可以减少CPU，内存的容量。进而节约成本。。 数据的话，个人的信息及各个应用的数据都是存储在云端中。我们有一个私人的账号，假如我们换了设备，我们可以通过登陆账号同步你的的信息。 在应用上。将是基于web的app。各个应用之间能够相互的联系，同时我想要添加某个应用的时候我们可以去应用商店直接添加。 开发环境的配置的话能够直接通过向云端要求什么环境，然后自动给你配置完毕，不用自己手动配置。 对大型游戏可以采用本地优化，比如针对游戏环境进行特殊的处理。 软件提供商，就像QQ音乐网页版那样。但是需要的功能需要更加的全面。 不足的地方 浏览器的性能必须足够强劲。 网速必须够快 网络问题，随时随地能够连上网 软件提供商必须要跟上这个系统的更新 。]]></content>
      <tags>
        <tag>瞎想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpu查看]]></title>
    <url>%2F2019%2F04%2F15%2Fcpu%2F</url>
    <content type="text"><![CDATA[linux 查看物理cpu个数，核数，逻辑cpu个数总核数 = 物理cpu个数 * 每颗cpu的核数总逻辑cpu个数 = 物理cpu个数 每颗cpu的核数 超线程数 查看物理cpu个数cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l 查看每个物理cpu的core的个数 (就是核数)cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq 查看逻辑CPU的个数cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l 查看CPU信息（型号）cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c]]></content>
      <tags>
        <tag>linux</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro jwt]]></title>
    <url>%2F2019%2F04%2F15%2Fjwt_shiro%2F</url>
    <content type="text"><![CDATA[spring-boot-jwtjwt做一个授权管理 api 序言 半吊子一个，大家有什么好意见或是简介，务必issue下 项目地址： https://github.com/liliangbin/spring-boot-jwt 同样，感谢一位大佬，也是在他的项目基础上建立起来的。 他的项目地址 ：https://github.com/Smith-Cruise/Spring-Boot-Shiro 但是同样因为他在于数据库的连接上没有搞定，所以也就是有了这个例子 不讲具体方法，说说程序的逻辑。第一步，shiro ，jwt maven配置。 12345678910&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 添加shiro俩个基类。 shiroConfig 这个类是shiro的主入口。。包含的是shiro框架使用的逻辑。 使用逻辑。。请求从shiroConfig这个类进去，然后经过过滤器，，过滤器是自己重写的，JwtAuthenticationFilter 只有过滤没有报错才能进入myealm这地方。。 而进去myRealm后，进行的是doGetAuthenticationInfo 。这个类主要的是判断密码和用户名是否正确，(因为我们使用的是jwt传递过来的是一个token，，所以最后校验的时候哪里填的是俩个token，如果觉得有问题可以看看最后返回的那个类的参数。。） 当我们的密码校验完毕后，我们才是最后的登陆成功。。。我们才能使用他的权限使用。 同样这个类也是对于url匹配关系的配置。。 ` Map&lt;String, String&gt; filterRuleMap = new HashMap&lt;&gt;(); // 所有请求通过我们自己的JWT Filter filterRuleMap.put(“/**”, “jwt”); // 访问401和404页面不通过我们的Filter filterRuleMap.put(“/401”, “anon”); filterRuleMap.put(“/login”,”anon”); filterRuleMap.put(“/name”,”anon”); //当然也是可以在controller中通过注解配置。 myRealm 该类的主要作用是鉴权和授权。 doGetAuthorizationInfo 这个方法主要是用来获取用户的权限，和角色。 doGetAuthenticationInfo 这个方法的作用主要是用来登陆的 jwt，需要做什么。 在jwt中我们会使用到一个token类，作为中间的一个传输对象。。在shiro中同样是有一个，所以我们需要的是让这个token类 实现一个接口 public class AccessToken implements AuthenticationToken //这个地方重载的俩个方法名字其实和myRealm里面最后密码验证时一样的，，所以我们在那个地方才传递的是来个相同的token @Override public Object getPrincipal() { return access_token; } @Override public Object getCredentials() { return access_token; } 因为要做的是前后端分离，所以也就是有了现在的这个样子，，放弃session cookie， 使用jwt鉴权。 apache shiro 当然还有其他的功能，，，另外有一个关于shiro的例子， https://github.com/liliangbin/apache-shiro]]></content>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2019%2F04%2F15%2Fmysql%2F</url>
    <content type="text"><![CDATA[今天学到了一个命令。用于远程登陆数据库1mysql -u yibantest -h 121.251.255.96 -p //passwd 在这个命令里 -u ：代表以什么身份登陆 user -&gt;root / yibantest -p : 代表的是密码 password -h ：远程终端 host]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springframework]]></title>
    <url>%2F2019%2F04%2F15%2Fspring-learn-%2F</url>
    <content type="text"><![CDATA[spring学习笔记 123456789101112@RestControllerpublic class GreetingController &#123; private static final String template = "Hello, %s!"; private final AtomicLong counter = new AtomicLong();//这个地方最想说的是俩个东西： format 和 atomicLong ，线程安全 @RequestMapping("/greeting") public Greeting greeting(@RequestParam(value="name", defaultValue="World") String name) &#123; return new Greeting(counter.incrementAndGet(), String.format(template, name)); &#125;&#125; spring项目启动的方法 两种方法 直接运行： ./mvnw spring-boot:run //直接运行的就是该springboot 项 jar包运行 ： ./mvnw clean package//打包成jar包 java -jar target / gs-rest-service-0.1.0.jar//运行该包]]></content>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh learn]]></title>
    <url>%2F2019%2F04%2F15%2Fssh%2F</url>
    <content type="text"><![CDATA[Linux ssh ssh的意义 这是一个用的是远程登录的操作。同时可以用于文件的上传和下载 相比于密码登录。这样不会中间人截取数据，（除了在第一次登录时被截取了数据） 思想。本地创建一个公钥，同时提交给服务器。在第一次登录的时候输入密码，下次登录的时候直接用ssh username@host 然后主机看是否能够解析出密码，如果能够接下出来，则是正确的。这样就不会出现 ssh操作 直接登陆的方式（每次都是需要输入密码） 12345 $ ssh user@host // //另外一种方式 $ ssh -p 8080 user@host //在这个地方登录的是以8080端口与登录 。ssh 默认的端口是22然后输入密码： 用ssh 公钥登录 本地看是否有公钥了如果没有执行此项操作 1$ ssh-keygen //这个是在本地生成一个公钥 然后把你的秘钥提交到服务器 1$ ssh-copy-id user@host 然后就是能够直接通过 ssh user@host 访问服务器了 备注 host 可以是你的ip 例如 127.0.0.1 类型的 或是例如域名 yb.upc.edu.cn]]></content>
      <tags>
        <tag>linux</tag>
        <tag>服务器运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinking]]></title>
    <url>%2F2019%2F04%2F06%2Fthinking%2F</url>
    <content type="text"><![CDATA[自闭的第一千零一天（骗你的） 现在开始真正写博客 还有，，爱你哟。 迁移博客完毕]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
